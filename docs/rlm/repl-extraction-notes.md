# REPL抽出メモ（ドラフト）

目的: RLM論文とその実装が前提にしている「REPL（入力→評価→出力/状態）」のインターフェース/振る舞いを抽出し、
その上で安全・決定的・文字列特化のサブセットをRustで実装できるように仕様化する。

このファイルは作業用メモです。仕様として確定した内容は、日付付きの設計ドキュメントとして `docs/plans/` に移します。

## ここでいう「REPL」とは
- RLMシステムが使うPython風スニペットを評価できる、制限付きの実行環境:
  - 文字列/構造化テキストを加工する
  - 変数に状態を保持してターン間で引き回す
  - （元のRLMでは）`query(...)` のようなAPIでLLM呼び出しを行う可能性がある
    - ただし本Rust実装ではネットワークは許可しない

## 実装で検証したい仮説
- 論文中の「プログラム」は単一行の式だけでなく、Pythonコードブロック（複数行）として記述されている可能性が高い
- 必要になりそうな要素（要検証）:
  - 代入（`x = ...`）
  - 文字列リテラル、連結、簡易フォーマット
  - インデックス/スライス（要否は未確定）
  - 最低限の list/dict（要否は未確定）
  - ランタイム提供のヘルパ（例: `query`、結果整形）

## 真実を抽出するためのデータソース（優先順）
1. 公式repo内のテスト/評価ハーネス
2. 論文が参照する公開データセット/評価タスク定義
3. 非公式実装の挙動（互換性の参考情報）

## 抽出で得たい成果物
- 「ゴールデントランスクリプト」一式:
  - 入力スニペット
  - 出力テキスト（stdout/stderr）
  - 構造化された結果（ある場合）
  - エラー分類（構文/型/実行時）と、決定的なフォーマット規則
- Rustで実装する構文ノード/操作の最小allowlist

## 実測結果（暫定; 2026-01-24 時点）
### 論文中の ```repl ブロック（arXiv HTML抽出）の静的特徴
（`extracted/paper/repl_blocks/*.py` と `extracted/paper/repl_ast_features.json` より）
- 複数行コードが前提（代入/for/if が出現）
- `import re` が出現（2箇所）
- 呼び出し/利用の例: `print`, `llm_query`, `enumerate`, `len`, `any`, `range`
- 文字列処理の例: f-string（JoinedStr）, `lower`, `"".join(...)`
- 正規表現の例: `re.split(...)`

### 非公式実装（ysz/recursive-llm）の挙動
（詳細ログ: `docs/rlm/unofficial-baseline-run.md`, `docs/rlm/eval/repl-probe-results.md`）
- `import` は遮断される（`__import__ not found`）
- ただし `re` はグローバルに注入されており、import無しで `re.findall/...` が動く
- list comprehension の式側で外側変数（`context`）を参照すると NameError になるケースがある
